//! Binary data encodings.
//!
//! * keycode: used for keys in the key/value store.
//! * bincode: used for values in the key/value store and network protocols.

pub mod bincode;
pub mod keycode;

use crate::error::Result;
use serde::{de::DeserializeOwned, Deserialize, Serialize};

/// Adds automatic Keycode encode/decode methods to key enums. These are
/// primarily meant for keys stored in key/value storage engines.
pub trait Key<'de>: Serialize + Deserialize<'de> {
    /// Decodes a key from a byte slice using Keycode.
    fn decode(bytes: &'de [u8]) -> Result<Self> {
        keycode::deserialize(bytes)
    }

    /// Encodes a key to a byte vector using Keycode.
    ///
    /// In the common case, the encoded key is borrowed for a storage engine
    /// call and then thrown away. We could avoid a bunch of allocations by
    /// taking a reusable byte vector to encode into and return a reference to
    /// it, but we keep it simple.
    fn encode(&self) -> Vec<u8> {
        keycode::serialize(self)
    }
}

/// Adds automatic Bincode encode/decode methods to value types. These are used
/// not only for values in key/value storage engines, but also for e.g. network
/// protocol messages and other values.
pub trait Value: Serialize + DeserializeOwned {
    /// Decodes a value from a byte slice using Bincode.
    fn decode(bytes: &[u8]) -> Result<Self> {
        bincode::deserialize(bytes)
    }

    /// Decodes a value from a reader using Bincode.
    fn decode_from<R: std::io::Read>(reader: R) -> Result<Self> {
        bincode::deserialize_from(reader)
    }

    /// Decodes a value from a reader using Bincode, or returns None if the
    /// reader is closed.
    fn maybe_decode_from<R: std::io::Read>(reader: R) -> Result<Option<Self>> {
        bincode::maybe_deserialize_from(reader)
    }

    /// Encodes a value to a byte vector using Bincode.
    fn encode(&self) -> Vec<u8> {
        bincode::serialize(self)
    }

    /// Encodes a value into a writer using Bincode.
    fn encode_into<W: std::io::Write>(&self, writer: W) -> Result<()> {
        bincode::serialize_into(writer, self)
    }
}

/// Generates a key range for a key prefix, used e.g. for prefix scans.
///
/// The exclusive end bound is generated by adding 1 to the value of the last
/// byte. If the last byte(s) is 0xff (so adding 1 would overflow), we instead
/// find the latest non-0xff byte, increment that, and truncate the rest. If all
/// bytes are 0xff, we scan to the end of the range, since there can't be other
/// prefixes after it.
pub fn prefix_range(prefix: &[u8]) -> (std::ops::Bound<Vec<u8>>, std::ops::Bound<Vec<u8>>) {
    let start = std::ops::Bound::Included(prefix.to_vec());
    let end = match prefix.iter().rposition(|b| *b != 0xff) {
        Some(i) => std::ops::Bound::Excluded(
            prefix.iter().take(i).copied().chain(std::iter::once(prefix[i] + 1)).collect(),
        ),
        None => std::ops::Bound::Unbounded,
    };
    (start, end)
}

/// Blanket implementations for various types wrapping a value type.
impl<V: Value> Value for Option<V> {}
impl<V: Value> Value for Result<V> {}
impl<V: Value> Value for Vec<V> {}
impl<V1: Value, V2: Value> Value for (V1, V2) {}
impl<V: Value + std::cmp::Eq + std::hash::Hash> Value for std::collections::HashSet<V> {}
