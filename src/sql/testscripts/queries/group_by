# Tests GROUP BY clauses. See "aggregate" for aggregate function tests.

> CREATE TABLE test ( \
    id INT PRIMARY KEY, \
    "group" STRING, \
    "bool" BOOLEAN, \
    "int" INTEGER, \
    "float" FLOAT, \
    "string" STRING \
)
> INSERT INTO test VALUES (0, NULL,   NULL, NULL,   NULL,      NULL)
> INSERT INTO test VALUES (1, 'a',    TRUE,   -1,   3.14,      '')
> INSERT INTO test VALUES (2, 'b',    FALSE,  0,    NAN,       'abc')
> INSERT INTO test VALUES (3, 'a',    TRUE,   3,    -0.0,      'AB')
> INSERT INTO test VALUES (4, 'b',    TRUE,   42,   INFINITY,  'ðŸ‘‹')
> INSERT INTO test VALUES (5, 'a',    FALSE,  7,    NAN,       '')
> INSERT INTO test VALUES (6, 'b',    FALSE,  -1,   0.0,       'abc')

> CREATE TABLE other (id INT PRIMARY KEY, value STRING)
> INSERT INTO other VALUES (1, 'a'), (2, 'b')
---
ok

# Grouping with no input rows yields empty result.
[plan]> SELECT COUNT(id), MIN(id), MAX(id), SUM(id), AVG(id) FROM test WHERE FALSE GROUP BY id
---
Projection: #1, #2, #3, #4, #5
â””â”€ Aggregate: count(id), min(id), max(id), sum(id), avg(id) group by id
   â””â”€ Nothing

# Simple GROUP BY, including NULL group.
[plan]> SELECT "group", COUNT(*) FROM test GROUP BY "group"
---
Projection: test.group, #1
â””â”€ Aggregate: count(TRUE) group by group
   â””â”€ Scan: test
NULL, 1
a, 3
b, 3

[plan]> SELECT "group", COUNT(*), MIN("bool"), MAX("string"), SUM("int"), AVG("float") \
    FROM test GROUP BY "group"
---
Projection: test.group, #1, #2, #3, #4, #5
â””â”€ Aggregate: count(TRUE), min(bool), max(string), sum(int), avg(float) group by group
   â””â”€ Scan: test
NULL, 1, NULL, NULL, NULL, NULL
a, 3, FALSE, AB, 9, NaN
b, 3, FALSE, ðŸ‘‹, 41, NaN

# GROUP BY works on booleans.
[plan]> SELECT "bool", COUNT(*) FROM test GROUP BY "bool"
---
Projection: test.bool, #1
â””â”€ Aggregate: count(TRUE) group by bool
   â””â”€ Scan: test
NULL, 1
FALSE, 3
TRUE, 3

# GROUP BY works on integers.
[plan]> SELECT "int", COUNT(*) FROM test GROUP BY "int"
---
Projection: test.int, #1
â””â”€ Aggregate: count(TRUE) group by int
   â””â”€ Scan: test
NULL, 1
-1, 2
0, 1
3, 1
7, 1
42, 1

# GROUP BY works with floats, including a NAN group and -0.0 and 0.0 being equal.
[plan]> SELECT "float", COUNT(*) FROM test GROUP BY "float"
---
Projection: test.float, #1
â””â”€ Aggregate: count(TRUE) group by float
   â””â”€ Scan: test
NULL, 1
0, 2
3.14, 1
inf, 1
NaN, 2

# GROUP BY works on strings.
[plan]> SELECT "string", COUNT(*) FROM test GROUP BY "string"
---
Projection: test.string, #1
â””â”€ Aggregate: count(TRUE) group by string
   â””â”€ Scan: test
NULL, 1
, 2
AB, 1
abc, 2
ðŸ‘‹, 1

# GROUP BY works even if the group column isn't in the result.
[plan]> SELECT COUNT(*) FROM test GROUP BY "group"
---
Projection: #1
â””â”€ Aggregate: count(TRUE) group by group
   â””â”€ Scan: test
1
3
3

# GROUP BY works when there is no aggregate function.
[plan]> SELECT "group" FROM test GROUP BY "group"
---
Projection: test.group
â””â”€ Aggregate:  group by group
   â””â”€ Scan: test
NULL
a
b

# GROUP BY does not work with SELECT aliases (also the case in e.g. SQL server).
!> SELECT "group" AS g, COUNT(*) FROM test GROUP BY g
---
Error: invalid input: unknown field g

[plan]> SELECT "group", COUNT(*) FROM test AS t GROUP BY t."group"
---
Projection: group, #1
â””â”€ Aggregate: count(TRUE) group by t.group
   â””â”€ Scan: test as t
NULL, 1
a, 3
b, 3

!> SELECT "group", COUNT(*) FROM test AS t GROUP BY test."group"
---
Error: invalid input: unknown table test

# It errors when there is a non-group column.
!> SELECT "group", id FROM test GROUP BY "group"
---
Error: invalid input: field id must be used in an aggregate or GROUP BY expression

# It errors on unknown tables and columns.
!> SELECT COUNT(*) FROM test GROUP BY unknown
!> SELECT COUNT(*) FROM test GROUP BY unknown.id
---
Error: invalid input: unknown field unknown
Error: invalid input: unknown table unknown

# GROUP BY can be arbitrary expressions.
[plan]> SELECT COUNT(*) FROM test GROUP BY 1
---
Projection: #1
â””â”€ Aggregate: count(TRUE) group by 1
   â””â”€ Scan: test
7

[plan]> SELECT COUNT(*) FROM test GROUP BY id % 2
---
Projection: #1
â””â”€ Aggregate: count(TRUE) group by id % 2
   â””â”€ Scan: test
4
3

# GROUP BY can use an expression also used in the SELECT.
[plan]> SELECT id % 2, COUNT(*) FROM test GROUP BY id % 2
---
Projection: #0, #1
â””â”€ Aggregate: count(TRUE) group by id % 2
   â””â”€ Scan: test
0, 4
1, 3

# GROUP BY can't use an aliased expression.
!> SELECT id % 2 AS mod, COUNT(*) FROM test GROUP BY mod
---
Error: invalid input: unknown field mod

# GROUP BY can't use aggregate functions.
!> SELECT COUNT(*) FROM test GROUP BY MIN(id)
---
Error: invalid input: unknown function min

# GROUP BY works with multiple groups.
[plan]> SELECT "group", "bool", COUNT(*) FROM test GROUP BY "group", "bool"
---
Projection: test.group, test.bool, #2
â””â”€ Aggregate: count(TRUE) group by group, bool
   â””â”€ Scan: test
NULL, NULL, 1
a, FALSE, 1
a, TRUE, 2
b, FALSE, 2
b, TRUE, 1

# GROUP BY works with joins.
[plan]> SELECT t.id % 2, COUNT(*) FROM test t JOIN other o ON t.id % 2 = o.id GROUP BY t.id % 2
---
Projection: #0, #1
â””â”€ Aggregate: count(TRUE) group by t.id % 2
   â””â”€ NestedLoopJoin: inner on t.id % 2 = o.id
      â”œâ”€ Scan: test as t
      â””â”€ Scan: other as o
1, 3
